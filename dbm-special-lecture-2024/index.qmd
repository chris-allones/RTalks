---
title: "."
title-slide-attributes:
  data-background-image: "img/bg_sem.jpg"
  data-background-size: "cover"
format: 
  revealjs:
    theme: [simple, custom.scss]
    preview-links: true
    code-fold: false
    code-summary: "code"
    chalkboard: true
    slide-number: true
    footer: "SEM: fundamentals and applications | link: t.ly/G900"
engine: knitr
from: markdown+emoji
editor: visual
---

```{r}
#| echo: false
#| include: false
knitr::opts_chunk$set(comment = "", collapse = TRUE)

## working directory
setwd("~/GitHub-repo/RTalks/dbm-special-lecture-2024")

## Libraries
library(tidyverse)
library(readxl)
library(lavaan)
library(semPlot)
library(seminr)
library(janitor)
library(haven)

# data management
data <- haven::read_sav("data/HBAT.sav") |> 
  select(x6:x18) |>  
  select(-x15, -x17) |>  # removing variables with below acceptable MSA
  tibble() |> 
  clean_names()

hbat_data <- haven::read_sav("data/HBAT_SEM_NOMISSING.sav") %>% 
  select(JS1:SI4) %>% mutate_all(as.numeric)

```

## Outline

### Part I: Relevance and basics of SEM

- SEM growth in research applications

- Steps in doing SEM

- Basics of SEM

- CB-SEM vs. PLS-SEM

### Part II: Data to insights: SEM demo using R

- Exploratory Factor Analysis (EFA)

- Confirmatory and CB-SEM

- PLS-SEM

# Part I: Relevance and basics of SEM

## SEM growth in research applications {.center-text}


```{r}
#| echo: false
#| eval: false
read_excel("data/sem_articles.xlsx", sheet = 1) |> 
  mutate(subject_area = fct_reorder(subject_area, count)) |> 
  ggplot(aes(count, subject_area)) + 
  geom_col(fill = "#1d3557") +
  geom_text(aes(label = count), hjust = -0.5, size = 3) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 3e4)) +
  theme_minimal() +
  theme(plot.margin = margin(rep(20, 4)),
        plot.title = element_text(face = "bold"),
        axis.title.x = element_text(margin = margin(t=20))) +
  labs(title = "SEM related journal articles",
       subtitle = str_wrap("A total of 83,863 articles covering the period 1978-2023 found in the Scopus database", 70),
       x = "Number of articles indexed in the Scopus database",
       y = element_blank())

ggsave("img/sem_subject_area.jpeg", dpi = 300, width = 8, height = 7)
```

![](img/sem_subject_area.jpeg){fig-align="center" width=80%}


## SEM growth in research applications {.center-text}


```{r}
#| echo: false
#| eval: false

read_excel("data/sem_articles.xlsx", sheet = 2) %>% 
  filter(year < 2023) %>% 
  ggplot(aes(year, count)) + 
  geom_line(linewidth= 1) +
  geom_text(data = . %>% filter(year > 2010),
            aes(label = count), hjust = -0.5, size = 3) +
  scale_x_continuous(expand = c(0, 0), limits = c(1975, 2030), 
                     breaks = c(seq(1975, 2020, 10), 2022)) +
  scale_y_continuous(limits = c(0, 15e3), breaks = seq(0, 15e3, 2500)) +
  theme_minimal() +
  theme(plot.margin = margin(rep(20, 4)),
        plot.title = element_text(face = "bold"),
        axis.title.y = element_text(margin = margin(r=20))) +
  labs(title = "Growth of SEM related journal articles",
       subtitle = str_wrap("A total of 83,863 articles covering the period 1978-2023 found in the Scopus database", 75),
       y = "Number of articles indexed in the Scopus database",
       x = element_blank())

ggsave("img/sem_time.jpeg", dpi = 300, width = 7, height = 5)
```

![](img/sem_time.jpeg){fig-align="center"}


## Steps in doing SEM {.center-text}

- (revise the illustration, incorporating the PLS-SEM)

![](img/overview_factor.jpg){fig-align="center" width=40%}


## Basics of SEM {.center-text}

::: {.columns}

::: {.column .center-text}
### When to use SEM?
:::

::: {.column .center-text}
### Pre-requisites

:::

:::

## What is SEM?

::: columns
::: column
#### Measurement model

-   measurement part of a a full SEM model

-   confirmatory factor analysis
:::

::: column
![](img/measurement_part_2.jpg){fig-align="center"}
:::
:::


## What is SEM?

::: columns
::: column
#### Measurement model

-   measurement part of a a full SEM model

-   confirmatory factor analysis

#### Structural model

-   relationship between constructs

-   full sem model is combination of measurement and structural component
:::

::: column
![](img/structural_part_2.jpg){fig-align="center"}
:::
:::

## Basic SEM conventions

<br>

![](img/sem_convention_2.jpg){fig-align="center" width="90%" height="90%"}


## Main steps in SEM

1.  Defining constructs

2.  Developing the overall measurement model

3.  Specifying the structural model


## 1. Defining Constructs

### Dataset

::: columns
::: {.column width="40%"}
-   HBAT company

-   HBAT is interested in understanding what affects employee's attitudes and behaviors that contributes to employee's retension.
:::

::: {.column width="60%"}
```{r}
#| echo: false
#| class-output: "remark-code"
rmarkdown::paged_table(hbat_data)
```
:::
:::

## 1. Defining Constructs

-   Based on literature and preliminary interviews, a study was designed focusing on five key constructs.

    -   **Job satisfaction (JS)** : reactions resulting from an appraisal of one's job situation.

    -   **Organizational commitment (OC)**: extent to which an employees indentifies and feels part of HBAT.

    -   **Staying intention (SI)**: extent to which an employee intends to continue working for HBAT.

    -   **Environmental perceptions (EP)**: beliefs an employee has about day-to-day, physical working conditions.

    -   **Attitudes towards cowrokers (AC)**: attitudes an employee has toward the coworkers he/she interacts with on a regular basis.

## 1. Defining Constructs

::: columns
::: column
![](img/scale.png){fig-align="left"}
:::

::: column
![](img/scale2.png){fig-align="right"}
:::
:::

::: aside
Source: JF Hair et al. (2019) : Multivariate data analysis
:::

## 2. Developing overall measurement model

::: columns
::: column
-   Measurement theory model (CFA) for HBAT employees

-   Direction of the relationship between factors is not yet defined.

-   Focus on confirming the specified model with empirical model (using empirical data), hence confirmatory.
:::

::: column
![](img/hbat_measurement.png){fig-align="right" width="95%" height="95%"}
:::
:::

::: aside
Source: JF Hair et al. (2019): Multivariate data analysis
:::


## CFA model to structural model {.center-text}

![](img/cfa_sem.png){fig-align="center" width="70%" height="70%"}

## 3. Defining structural model

#### Hypotheses:

-   H1: Environmental perceptions are positively related to job satisfaction.

-   H2: Environmental perceptions are positively related to organizational commitment.

-   H3: Attitudes toward coworkers are positively related to job satisfaction.

-   H4: Attitudes toward coworkers are positively related to organizational commitment.

-   H5: Job satisfaction is related positively to organizational commitment.

-   H6: Job satisfaction is related positively to staying intentions.

-   H7: Organizational commitment is related positively to staying intention.

## 3. Defining structural model {.center-text}

![](img/structural_model.png){fig-align="center" width="80%" height="80%"}


#


### Excited to do SEM? {.center-text}

### Hold up! We need to do some exploratory first! {.center-text}

![](img/wait_what.gif){fig-align="center"}

# Exploratory Factor Analysis (EFA) {.center-text}

## EFA: an overview

- an exploratory or descriptive technique to determine the appropriate number of common factor.

- no specifications are made in regards to the number of factors (initially) or the pattern of relationships between  factor and indicators.

- looking for patterns in the data


## 3 main steps in EFA {.center-text}

::: {.columns}

::: {.column width=33%}
### Assessing data appropriateness {.left-text}

- Bartlett test

- Kaiser-Meyer-Olkin test (KMO)
:::


::: {.column width=33%}
### Deriving factors {.left-text}

- Kaiser-Guttman criterion

- Scree test

- Parallel test

:::


::: {.column width=33%}
### Factor interpretation {.left-text}

- Factor extraction

- Factor rotation

- Factor interpretation and re-specification

:::

:::


## Assessing data appropriateness

<br>

::: columns
::: {.column width="40%"}
#### 1. Bartlett Test

-   Examines the entire correlation matrix
-   Test the hypothesis that correlation matrix is an identity matrix.
-   A significant result signifies data are appropriate for factor analysis.
:::

::: {.column width="10%"}

:::

::: {.column width="50%"}
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"
library(EFAtools)
BARTLETT(data, N= nrow(data))
```

<br>

```{r}
#| echo: true
#| class-output: "remark-code"
library(EFAtools)
BARTLETT(data, N= nrow(data))
```
:::
:::

## Assessing data appropriateness

#### 2. Kaiser-Meyen-Olkin (KMO Test)

-   Measure of sampling adequacy
-   Indicate the proportion of variance explained by the underlying factor.
-   Guidelines:
    -   $\ge 0.90$ - marvelous
    -   $\ge 0.80$ - meritorious
    -   $\ge 0.70$ - middling
    -   $\ge 0.60$ - mediocre
    -   $\ge 0.50$ - miserable
    -   $< 0.50$ - unacceptable

## Assessing data appropriateness

#### 2. Kaiser-Meyen-Olkin (KMO Test)

```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"

library(psych)
KMO(data)
```

<br>

```{r}
#| echo: true
#| class-output: "remark-code"

library(psych)
KMO(data)
```

## Assessing data appropriateness

#### 2. Kaiser-Meyen-Olkin (KMO Test)

-   When overall MSA is less than 0.50
    -   Identify variables with lowest MSA subject for deletion.
    -   Recalculate MSA
    -   Repeat unitl overall MSA is 0.50 and above
-   Deletion of variables with MSA under 0.50 means variable's correlation with <br>other variables are poorly representing the extracted factor.


## Deriving factors

::: columns
::: {.column width="40%"}
#### 1. Kaiser-Guttman Criterion

-   Only consider factors whose eigenvalues is greater than 1.

-   Rationale is that factor should account for the variance of at least a single variable if it is to be retained for interpretation.
:::

::: {.column width="60%"}
```{r}
#| echo: true
#| eval: false
library(EFAtools)
KGC(data, eigen_type = "EFA")
```

![](img/kgc_plot.png){fig-align="center" width="130%"}
:::
:::

## Exploring possible factors

::: columns
::: {.column width="40%"}
#### 2. Scree test

-   Identify the optimum number of factors that can be extracted before the amount of unique variance begins to dominate the common variance.

-   Inflection point or the "elbow"
:::

::: {.column width="60%"}
```{r}
#| eval: false
#| echo: true

library(psych)
scree(data)
```

![](img/scree_plot.png){fig-align="center" width="130%"}
:::
:::

## Exploring possible factors

::: columns
::: {.column width="40%"}
#### 3. Parallel Test

-   Generates a large number of simulated dataset.
-   Each simulated dataset is factor analyzed.
    -   Results is the average eigenvalues across simulation.
    -   Values are then compared to the eigenvalues extracted from the original dataset.
    -   All factors with eigenvalues above those average eigenvalues are retained.
:::

::: {.column width="60%"}
```{r}
#| eval: false
#| echo: true

library(psych)
fa.parallel(data, fa = "fa")
```

![](img/parallel_plot.png){fig-align="center" width="130%"}
:::
:::


## Factor interpretation {.left-text}

### Three process of factor intepretation

#### 1. Factor extraction

#### 2. Factor rotation

#### 3. Factor interpretation and re-specification


## 1. Factor extraction

::: columns
::: {.column width="60%"}
```{r}
#| echo: true
#| eval: false

fa_unrotated <- fa(r = data, nfactors = 4, rotate = "none")
print(fa_unrotated$loadings)
```

<br>

```{r}
#| echo: true
#| class-output: "remark-code"

fa_unrotated <- fa(r = data, nfactors = 4, rotate = "none")
print(fa_unrotated$loadings)
```
:::

::: {.column width="40%"}
#### Loadings

-   Correlation of each variable and the factor.
-   Indicate the degree of correspondence between variable and factor.
-   Higher loadings making the variable representative of the factor.
:::
:::


## 1. Factor extraction

::: columns
::: {.column width="60%"}
```{r}
#| echo: true
#| eval: false

fa_unrotated <- fa(r = data, nfactors = 4,rotate = "none")
print(fa_unrotated$loadings)
```

<br>

```{r}
#| echo: true
#| class-output: "remark-code"

fa_unrotated <- fa(r = data, nfactors = 4,rotate = "none")
print(fa_unrotated$loadings)
```
:::

::: {.column width="40%"}
#### Loadings

-   $\le \pm 0.10 \approx$ zero

-   $\pm 0.10$ to $\pm 0.40$ meet the minimal level

-   $\ge \pm 0.50$ practically significant

-   $\ge \pm 0.70 \approx$ well-defined structure

#### SS loadings

-   Eigenvalues - column sum of squared factor loadings.

-   Relative importance of each factor in accounting for the variance associated with the set of variables.
:::
:::


## 2. Factor rotation

::: columns
::: column
#### Why do factor rotation?

-   To simplify the complexity of factor loadings.

-   Distribute the loading more clearly into the factors.

-   Facilitate interpretation.
:::

::: column
![](img/factor_rotation.png){fig-align="center" width="90%"}
:::
:::

## Factor rotation

::: columns
::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"

fa_rotated <- fa(r = data, nfactors = 4,rotate = "varimax")

par(mfrow = c(2, 1))
plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     pch = 19,
     cex = 2,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 1)

plot(fa_rotated$loadings[,1],
     fa_rotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "With rotation",
     pch = 19,
     cex = 2,
     col = "#6c757d")
     abline(h=0, v=0)
     text(fa_rotated$loadings[,1],
          fa_rotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 1)

```
:::

::: column
```{r}
#| echo: false
#| fig-height: 12
#| fig-align: center
#| class-output: "remark-code"

fa_rotated <- fa(r = data, nfactors = 4,rotate = "varimax")

par(mfrow = c(2, 1))
plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     pch = 19,
     cex = 2,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 1)

plot(fa_rotated$loadings[,1],
     fa_rotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "With rotation",
     pch = 19,
     cex = 2,
     col = "#6c757d")
     abline(h=0, v=0)
     text(fa_rotated$loadings[,1],
          fa_rotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 1)

```
:::
:::

## Factor rotation

::: columns
::: column
#### Orthogonal rotation

-   axes are maintained at 90 degrees

-   orthogonal rotation methods

    -   Varimax - *most commonly used*

    -   Quartimax

    -   Equimax

-   Check-out some of these references

    -   [IBM](https://www.ibm.com/docs/de/spss-statistics/24.0.0?topic=analysis-factor-rotation)

    -   [Factor analysis](http://statweb.stanford.edu/~susan/courses/stats305c/examplesFA.html)
:::

::: column
![](image/orthogonal.png){fig-align="center" width="100%"}
:::
:::

## Factor rotation

#### Orthogonal rotation

::: columns
::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"

fa_varimax <- fa(r = data, nfactors = 4,rotate = "varimax")
fa_quartimax <- fa(r = data, nfactors = 4,rotate = "quartimax")
fa_equamax <- fa(r = data, nfactors = 4,rotate = "equamax")

par(mfrow = c(2, 2))

plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 2)
     
plot(fa_varimax$loadings[,1],
     fa_varimax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Varimax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_varimax$loadings[,1],
          fa_varimax$loadings[,2],
          labels = rownames(fa_varimax$loadings),
          pos = 4, cex = 2)

plot(fa_quartimax$loadings[,1],
     fa_quartimax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Quartimax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_quartimax$loadings[,1],
          fa_quartimax$loadings[,2],
          labels = rownames(fa_quartimax$loadings),
          pos = 4, cex = 2)
     
plot(fa_equamax$loadings[,1],
     fa_equamax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Equamax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_equamax$loadings[,1],
          fa_equamax$loadings[,2],
          labels = rownames(fa_equamax$loadings),
          pos = 4, cex = 2)



```
:::

::: column
```{r}
#| echo: false
#| fig-height: 20
#| fig-width: 18
#| fig-align: center
#| class-output: "remark-code"

fa_varimax <- fa(r = data, nfactors = 4,rotate = "varimax")
fa_quartimax <- fa(r = data, nfactors = 4,rotate = "quartimax")
fa_equamax <- fa(r = data, nfactors = 4,rotate = "equamax")

par(mfrow = c(2, 2))

plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 2)
     
plot(fa_varimax$loadings[,1],
     fa_varimax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Varimax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_varimax$loadings[,1],
          fa_varimax$loadings[,2],
          labels = rownames(fa_varimax$loadings),
          pos = 4, cex = 2)

plot(fa_quartimax$loadings[,1],
     fa_quartimax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Quartimax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_quartimax$loadings[,1],
          fa_quartimax$loadings[,2],
          labels = rownames(fa_quartimax$loadings),
          pos = 4, cex = 2)
     
plot(fa_equamax$loadings[,1],
     fa_equamax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Equamax",
     cex.main = 3,
     pch = 19,
     cex = 4,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_equamax$loadings[,1],
          fa_equamax$loadings[,2],
          labels = rownames(fa_equamax$loadings),
          pos = 4, cex = 2)



```
:::
:::

## Factor rotation

::: columns
::: column
#### Oblique rotation rotation

-   allow correlated factors

-   suited to the goal of theoretically meaningful constructs

-   oblique rotation methods

    -   Promax

    -   Oblimin
:::

::: column
![](image/oblique.png){fig-align="center" width="90%"}
:::
:::

## Factor rotation

#### Oblique rotation

::: columns
::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"

fa_promax <- fa(r = data, nfactors = 4,rotate = "promax")
fa_oblimin <- fa(r = data, nfactors = 4,rotate = "oblimin")


par(mfrow = c(1, 3))

plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     pch = 19,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 0.5)
     
plot(fa_promax$loadings[,1],
     fa_promax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Promax",
     pch = 19,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_promax$loadings[,1],
          fa_promax$loadings[,2],
          labels = rownames(fa_promax$loadings),
          pos = 4, cex = 0.5)

plot(fa_oblimin$loadings[,1],
     fa_oblimin$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Oblimin",
     pch = 19,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_oblimin$loadings[,1],
          fa_oblimin$loadings[,2],
          labels = rownames(fa_oblimin$loadings),
          pos = 4, cex = 0.5)
     
```
:::

::: column
```{r}
#| echo: false
#| fig-height: 11.7
#| fig-align: center
#| class-output: "remark-code"

fa_promax <- fa(r = data, nfactors = 4,rotate = "promax")
fa_oblimin <- fa(r = data, nfactors = 4,rotate = "oblimin")


par(mfrow = c(3, 1))

plot(fa_unrotated$loadings[,1],
     fa_unrotated$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "No rotation",
     cex.main = 2.5,
     pch = 19,
     cex = 2,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_unrotated$loadings[,1],
          fa_unrotated$loadings[,2],
          labels = rownames(fa_unrotated$loadings),
          pos = 4, cex = 2)
     
plot(fa_promax$loadings[,1],
     fa_promax$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Promax",
     cex.main = 2.5,
     pch = 19,
     cex = 2,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_promax$loadings[,1],
          fa_promax$loadings[,2],
          labels = rownames(fa_promax$loadings),
          pos = 4, cex = 2)

plot(fa_oblimin$loadings[,1],
     fa_oblimin$loadings[,2],
     xlab = "Factor 1",
     ylab = "Factor 2",
     ylim = c(-1, 1),
     xlim = c(-1, 1),
     main = "Oblimin",
     cex.main = 2.5,
     pch = 19,
     cex = 2,
     col = "#6c757d") 
     abline(h=0, v=0)
     text(fa_oblimin$loadings[,1],
          fa_oblimin$loadings[,2],
          labels = rownames(fa_oblimin$loadings),
          pos = 4, cex = 2)
     
```
:::
:::

## Factor interpretation and respecification

::: columns
::: column
-   each variable has a high loadings on one factor only

-   each factor has a high loadings for only a subset of the items.
:::

::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE)
```

<br>

```{r}
#| echo: true
#| eval: true
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE)
```
:::
:::

## Factor interpretation and respecification

::: columns
::: column
-   each variable has a high loadings on one factor only

-   each factor has a high loadings for only a subset of the items.
:::

::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE, cutoff = 0.4)
```

<br>

```{r}
#| echo: true
#| eval: true
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE, cutoff = 0.4)
```
:::
:::

## Factor interpretation and respecification

::: columns
::: column
What to do with cross-loadings?

Ratio of variance (*JF Hair et al. 2019*)

-   1 to 1.5 - problematic
-   1.5 to 2.0 - potential cross-loading
-   2.0 and higher - ignorable

Example:

-   $X_{11}$
-   `MR1`: 0.525
-   `MR2`: 0.712
-   $0.712^2 \div 0.525^2 = 1.8$
:::

::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE, cutoff = 0.4)
```

<br>

```{r}
#| echo: true
#| eval: true
#| class-output: "remark-code"
fa_varimax <- fa(r = data, nfactors = 4, rotate = "varimax")
print(fa_varimax$loadings, sort = TRUE, cutoff = 0.4)
```
:::
:::

## Factor interpretation and respecification

#### Naming of factors

::: columns
::: column
-   **MR1: Postsale customer service**

    -   x9 Complaint resolutions

    -   x16 Order & Billing

    -   x18 Delivery speed

-   **MR2: Marketing**

    -   x7 E-Commerce

    -   x10 Advertising

    -   x12 Salesforce image
:::

::: column
-   **MR3: Technical support**

    -   x8 Technical support

    -   x14 Warranty and claims

-   **MR4: Product value**

    -   x6 Product quality

    -   x11 Product line

    -   x13 Competitive pricing
:::
:::

------------------------------------------------------------------------

## Factor interpretation and respecification

#### Extracting factor scores

::: columns
::: column
-   **MR1: Postsale customer service**

-   **MR2: Marketing**

-   **MR3: Technical support**

-   **MR4: Product value**
:::

::: column
```{r}
#| echo: true
#| eval: false
#| class-output: "remark-code"
fa_varimax$scores %>% round(4) %>% data.frame() %>% tibble()
```

<br>

```{r}
#| echo: true
#| eval: true
#| class-output: "remark-code"
fa_varimax$scores %>% round(4) %>% data.frame() %>% tibble()
```
:::
:::

# Let's practice!








